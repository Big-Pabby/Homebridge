// let's imagine this file is autogenerated from the backend
// ideally, we want to keep these api related types in sync
// with the backend instead of manually writing them out

export type BaseEntity = {
  id?: string;
  date_created?: string;
  date_updated?: string;
  deleted_at?: string;
};

export type Entity<T> = {
  [K in keyof T]: T[K];
} & BaseEntity;

// export type Meta = {
//   page: number;
//   total: number;
//   totalPages: number;
// };

export type User = Entity<{
  student_id: string;
  name: string;
  email: string;
  phone_number: string;
  gender: "Male" | "Female" | string;
  birth_date: string; // ISO format datetime
  competition_track: string;
  school_name: string;
  education_district: string;
  current_class: string;
  supporting_teacher: string;
  guardian_name: string;
  guardian_email: string;
  guardian_phone_number: string;
  guardian_relationship: string;
}>;

export type RefreshResponse = {
  accessToken: string;
  refreshToken: string;
};

export type AuthResponse = {
  student: User;
  access_token: string;
  refresh_token: string;
  expires_in: string;
};

// Generic API Response wrapper for all API calls
export type ApiResponse<T> = {
  success: boolean;
  message: string;
  data: T;
};

// Paginated data wrapper (used within ApiResponse)
export type PaginatedData<T> = {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
};

// Combined type for paginated API responses
export type ApiPaginatedResponse<T> = ApiResponse<PaginatedData<T>>;

